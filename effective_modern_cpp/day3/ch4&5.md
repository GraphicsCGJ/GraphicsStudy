# 목차
소유권 독점 자원의 관리에는 std::unique_ptr를 사용하라
소유권 공유 자원의 관리에는 std::shared_ptr를 사용하라
std::shared_ptr처럼 작동하되 대상을 잃을 수도 있는 포인터가 필요하면 std::wak_ptr를 사용하라
new를 직접 사용하는 것보다 std::make_unique와 std::make_shared를 선호하라
Pimpl 관용구를 사용할 때에는 특수 멤버 함수들을 구현 파일에서 정의하라
std::move와 std::forwardc를 숙지하라보편 참조와 오른값 참조를 구별하라
오른값 참조에는 std::move를, 보편 참조에는 std::forward를 사용하라
#### 18. 소유권 독점 자원은 std::unique_ptr
#### 19. 소유권 공유 자원은 std::sahred_ptr
#### 20. 잃을 수도 있는 공유 자원 std::weak_ptr
#### 21. new를 사용하는 것보다 make_unique, make_shared 선호
#### 22. Pimpl 관용구를 사용할 때 특수 멤버 함수 정의
#### 23. std::move 와 std::forward 숙지
#### 24. 보편 참조와 오른값 참조 구별
#### 25. 오른값 참조에는 move, 보편 참조에는 foward 사용
---

# 4장 똑똑한 포인터

생 포인터를 사용하기 힘든 이유
1. 선언으로 객체와 배열을 구분하기 힘듦
2. 객체의 소유권여부 파악하기 힘듦
3. 객체의 파괴 매커니즘 알아야 할 수 있음 (delete 가 아닌 별도 매커니즘 사용 가능성 존재)
4. 파괴 하더라도 배열의 파괴인지 객체의 파괴인지 알 수 없음
5. 여러 곳에서 포인터를 소유할 수 있지만, 딱 한번 파괴되어야 한다.
6. Dangling ptr 문제가 발생 가능

이러한 문제점을 해결하기 위한 스마트 포인터 네 가지
 - `std::auto_ptr`
 - `std::unique_ptr`
 - `std::shared_ptr`
 - `std::weak_ptr`

단, c++11 이후로는 `unique_ptr` 이 `auto_ptr` 의 상위 호환이므로 `unique_ptr` 만을 고려한다.

---
## Item 18. 소유권 독점 자원은 `unique_ptr` 를 사용

### std::unique_ptr 특징
- 독점 소유권 의미론을 가진 자원을 위해 사용 (항상 자신이 가리키는 객체 독점 소유, 이동시 소유권 이전)
- 생 포인터와 같은 크기의 메모리 사용
- 이동 전용 형식 (move-only type), 복사를 허용하지 않는다

### Hierarchy 안의 객체를 생성하는 팩터리 함수의 반환으로 보통 사용
```cpp
class Investment { 
};

class Stock :
    public Investment {
};

class Bond :
    public Investment {
};

class RealEstate :
    public Investment {
};

template <typename... Ts> 
std::unique_ptr<Investment> makeInvestment(Ts&&... params);
{
    // pInvestment의 타입은 std::unique_ptr<Investment> *pInvestment가 파괴된다.   
    auto pInvestment = makeInvestment(인수들);   
}
```
 이런 팩터리 함수는 힙에 객체를 생성하고 포인터를 리턴한다. 이 객체에 대한 소유권은 온전히 이 함수를 호출한 호출자의 몫이다. 즉, 팩터리 함수는 객체를 생성하고 소유권을 호출자를 이전하기만 하면 되기 때문에 `unique_ptr` 의 사용은 적합하다.

 `unique_ptr` 은 객체를 위한 것(`std::unique_ptr<T>`)과 배열을 위한 것(`std::unique_ptr<T[]>`)이 있다. 이 때문에 생 포인터와는 다르게 포인터가 객체를 가르키는지, 배열을 가르키는지에 대한 애매함으 해소된다. 하지만 내장 배열보다는 `std::array`나 `std::vector`을 사용하기를 추천한다.


 ### 기본적인 파괴는 delete를 통해 일어나나, 커스텀 삭제자를 지정할 수 있다.
 자원의 파괴는 기본적으로 delete를 통해서 일어나지만, `std::unique_ptr`객체 생성시 커스텀 삭제자를 사용하도록 등록할 수 있다.
 ```cpp
 auto delInvmt = [](Investment* pInvestment) // 커스텀 삭제자
{                                
    makeLogEntry(pInvestment);   
    delete pInvestment;          
}

template <typename... Ts>
std::unique_ptr<Investment, decltype(delInvmt)>
makeInvestment(Ts&&... params)
{
    std::unique_ptr<Investment, decltype(delInvmt)>
        pInv(nullptr, delInvmt);

    if ( /* Stock 객체를 생성해야 하는 경우 */)
    {
        pInv.reset(new Stock(std::forward<Ts>(params)...));
    }
    else if ( /* Bond 객체를 생성해야 하는 경우 */)
    {
        pInv.reset(new Bond(std::forward<Ts>(params)...));
    }
    else if ( /* RealEstate 객체를 생성해야 하는 경우 */)
    {
        pInv.reset(new RealEstate(std::forward<Ts>(params)...));
    }

    return pInv;
}
 ```
 - 모든 커스텀 삭제 함수는 파괴할 객체 하나를 받으며 삭제하는데 필요한 일을 수행한다.
   - `delInvmt`는 `makeInvestment`가 돌려준 객체에 대한 커스텀 삭제자
 - 커스텀 삭제자 사용시 그 타입을 `unique_ptr`의 둘째 타입 인수로 지정해야 한다.
   - 예시의 삭제자 타입은 `delInvmt`
 - 예시의 기본 전략은 `nullptr` 값인 `unique_ptr`를 만들어서 적절한 객체를 가리키게 한 후 돌려주는 것이다.
 - 생 포인터를 `unique_ptr`에 대입하는 것은 컴파일 되지 않는다.
   - 때문에 `reset`함수를 호출했다.
 - 기반 클래스를 매개변수로 받고 기반 클래스의 소멸자를 호출하기 때문에 기반 클래스의 소멸자는 가상 소멸자야 한다.

```cpp
auto delInvmt1 = [](Investment* pInvestment) // 상태 없는 람다 형태의 삭제자
{                                    
    makeLogEntry(pInvestment);       
    delete pInvestment;
}

template <typename... Ts> // 반환 타입은 Investment*와 같은 크기
std::unique_ptr<Investment, decltype(delInvmt1)> makeInvestment(Ts&&... args);                       

void delInvmt2(Investment* pInvestment) // 함수 형태의 삭제자
{
    makeLogEntry(pInvestment);
    delete pInvestment;
}

template <typename... Ts> // 반환 타입의 크기는 Investment*의 크기에 적어도 함수 포인터의 크기를 더한 것임!
std::unique_ptr<Investment, void (*)(Investment*)> makeInvestment(Ts&&... params);   
```

커스텀 소멸자를 사용한다면 `unique_ptr`크기는 달라진다.
 - 함수포인터의 경우 `unique_ptr`크기가 1워드에서 2워드로 증가
 - 함수 객체는 저장된 상태만큼 크기 증가
 - 람다는 상태(캡처)가 없다면 크기 변화가 없다

따라서 캡처가 없는 람다를 사용하는것이 바람직하다.

### `unique_ptr`를 `shared_ptr`로 손쉽게 변환할 수 있다
`unique_ptr`의 경우 다음과 같이 손쉽게 `shared_ptr`로 변환이 가능하다
```cpp
std::shared_ptr<Investment> sp = makeInvestment( params );
```
하지만 반대로 `shared_ptr`를 `unique_ptr`로 변환하는 것은 불가능하다.
따라서 팩터리 함수는 호출자가 객체를 독점적으로 소유하는지, 공유하려는지 모르기 때문에 `unique_ptr`로 반환하는 것이 합당하다.


