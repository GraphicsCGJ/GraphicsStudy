- [6. 재사용을 고려한 설계](#6-재사용을-고려한-설계)
  - [6.1 재사용 철학](#61-재사용-철학)
  - [6.2 코드를 재사용할 수 있도록 설계하는 방법](#62-코드를-재사용할-수-있도록-설계하는-방법)
    - [6.2.1 추상화 방법](#621-추상화-방법)
    - [6.2.2 재사용에 최적화된 코드 구조화](#622-재사용에-최적화된-코드-구조화)
      - [6.2.2.1 서로 관련 없거나 논리적으로 구분되는 개념을 합치지 않기.](#6221-서로-관련-없거나-논리적으로-구분되는-개념을-합치지-않기)
      - [6.2.2.2 범용 데이터 구조와 알고리즘을 템플릿으로 구현하기](#6222-범용-데이터-구조와-알고리즘을-템플릿으로-구현하기)
      - [6.2.2.3 적절한 검사 기능과 안전 장치 제공하기.](#6223-적절한-검사-기능과-안전-장치-제공하기)
      - [6.2.2.4. 확장성을 고려한 설계](#6224-확장성을-고려한-설계)
    - [6.2.3 사용성 높은 인터페이스 설계](#623-사용성-높은-인터페이스-설계)
      - [6.2.3.1 사용자 고려하기](#6231-사용자-고려하기)
      - [6.2.3.2 용도 고려하기](#6232-용도-고려하기)
      - [6.2.3.3 인터페이스를 사용하기 쉽게 설계하기](#6233-인터페이스를-사용하기-쉽게-설계하기)
      - [6.2.3.4 범용 인터페이스 설계](#6234-범용-인터페이스-설계)
      - [6.2.3.5 범용성과 사용성의 조화](#6235-범용성과-사용성의-조화)
    - [6.2.4 바람직한 추상화 설계](#624-바람직한-추상화-설계)
    - [6.2.5 솔리드 원칙](#625-솔리드-원칙)
  - [6.3 정리](#63-정리)
  - [6.4 연습 문제](#64-연습-문제)
    - [6.4.1 공통적으로 사용되는 기능을 더욱 쉽게 만들고, 동시에 고급 기능에 대한 옵션도 제공한다는 말이 무슨 뜻인지 생각해보자.](#641-공통적으로-사용되는-기능을-더욱-쉽게-만들고-동시에-고급-기능에-대한-옵션도-제공한다는-말이-무슨-뜻인지-생각해보자)
    - [6.4.2 재사용 가능한 코드 설계를 위한 최선의 전략은?](#642-재사용-가능한-코드-설계를-위한-최선의-전략은)
    - [6.4.3 문제는 하단](#643-문제는-하단)
    - [6.4.4 SOLID 안보고 대답하기.](#644-solid-안보고-대답하기)


# 6. 재사용을 고려한 설계

설계가 잘 된 라이브러리와 그렇지 않은 라이브러리 차이는 매우 크다.

잘못 설계된건 걍 버리고 내가 새로 짜고싶게끔 만든다.

따라서 항상 재사용성을 염두해두고 코드 설계를 해야한다.

4장에선 재사용성있는 코드를 써야된다만 알려주고 방법은 안알려줌

여기서 그걸 볼것

## 6.1 재사용 철학

항상 아래의 철학을 명심할 것.

* 작성은 한 번, 사용은 여러번
* 무슨 수를 써서라도 코드 중복은 피한다.
* 같은 일을 반복하지 않는다.

이에 대한 근거는 다음과 같다.

* **코드를 한 프로그램에서만 사용하는 경우는 극히 드물다.**
* **재사용 할 수 있게 설계해야 시간/비용 절약 가능하다.**
* **팀 내 다른 프로그래머도 활용할 수 있도록 작성해야 한다.**
* **재사용성이 낮으면 코드 중복이 늘어난다.**
* **재사용하기 좋은 코드의 첫 번째 수혜자는 본인**

## 6.2 코드를 재사용할 수 있도록 설계하는 방법

**재사용할 수 있게 만드는 방법** 은 두가지이다.
* 범용성을 갖춰야 한다.
  * 특정 용도에만 너무 특화되게 짜면 다른 프로그램에서 사용하기가 어려움
* 사용하기 쉽게 만들어야 한다.
  * 인터페이스 / 기능을 금방 이해하게 만들어야함.

전달 방식도 고민해봐야 한다.
* so / dll 형태의 동적 라이브러리
* 소스코드 전체를 그냥 공유

### 6.2.1 추상화 방법

위 이유들로 인해 코드 작성에 있어서 가장 중요한 것은 추상화이다.

추상화의 핵심은 아래 2가지이다.
* **구현**
  * 원하는 작업을 달성하기 위해 작성한 `코드`
* **인터페이스**
  * 이렇게 작성한 `코드`를 사용하기 위한 `수단`

OOP 관점에서 이를 처리하려면 `public`처리를 잘 해줘야함. 잘 정의된 인터페이스는 `public`메서드만 가지고있음.

`attribute`에 대한 접근도 `getter` / `setter`로만 접근해야 가독성이 좋고 이해하기 좋음.

`핸들` 이란 개념을 알아도 좋다. `핸들` 은 특정 인터페이스를 사용하는 객체 / 라이브러리의 상태를 저장해놓기 위한 변수이다.

예를 들면, DB에 붙는다고 할 때, DB연결을 위한 핸들 (Java의 JDBC 등등) 이 존재하고, 해당 핸들 내부에 연결 상태나 변수들이 저장되어 메소드 호출시마다 상태가 변경된다.

이런 핸들은 보통 `불투명(opaque)` 클래스 처리가 되어, 내부 변수에 대한 직접 접근이 아예 불가능하거나 setter를 통해서만 변경된다.

> c++은 public 인터페이스와 private 데이터 및 메서드를 한 클래스에서 처리해야함.
> 이로인해 소스코드가 공개될 수 밖에 없다. (뭔말인진 잘 모르겠다. 되지않나?)

추상화를 통해 재사용을 하려면 아래 두 가지에 주안점을 두자.
* **코드를 적절하게 구성**
  * 클래스 계층 구조 / 템플릿 / 서브시스템 등을 고려
* **인터페이스를 설계**
  * 진입점 역할을 하기 때문에 잘 설계해야함.

### 6.2.2 재사용에 최적화된 코드 구조화

재사용할 수 있는 코드는 설계를 시작할 때 부터 함수와 이를 구성하는 클래스, 라이브러리, 프레임워크 전체에 이르는 모든 계층을 전반적으로 고려해야 함

이러한 계층들을 `컴포넌트` 라고 부른다고 함

#### 6.2.2.1 서로 관련 없거나 논리적으로 구분되는 개념을 합치지 않기.

`컴포넌트`는 반드시 한 작업만 처리하도록 설계해야함. 즉 **응집도** 를 높이는 데에 주력해야함.

이를 **단일 책임 원칙(Single Responsibility Principle)** 라고 한다.

재사용을 고려하지 않는 코드라도 이건 고려하는게 좋다. 커플링 없이 기능 별로 단일 `컴포넌트`에 때려박아야된다.

**1-1. 프로그램을 서브시스템 단위로 논리적으로 나누기**

위에서 말한 **커플링** 을 줄여야함. 잘 설계된 인터페이스와 기능을 논리적으로 명확히 구분해놔라.

**1-2. 클래스 계층을 사용해서 논리적으로 나누기**

자율 주행 자동차 관련 코드를 짤 때 모두 한 코드에 때려넣으면, 자동차 기능만 사용하는 다른 객체 등에서 필요 없는 자율주행 부분까지 링크되어버림.

```bash
  +----------------+
  |      Car       |
  +----------------+
          ^
          |
  +---------------------+
  |  SelfDrivingCar     |
  +---------------------+
```

개념이 3개 이상일 땐 좀 복잡하다.

트럭 / 승용차 / 자율 주행 유무가 있다고 하자.

```bash
        +----------------+
        |    Vehicle     |
        +----------------+
               ^
               |
     +---------+---------+
     |                   |
+----------------+   +----------------+
|      Car       |   |      Truck     |
+----------------+   +----------------+
```

이러면 자율 주행 여부를 판단하기가 어렵다. 이럴 때 앞장에서 말한 믹스인을 구현하는게 좋다.

템플릿 문법을 사용할텐데 우선은 무시하라고 한다.

```c++
template <typename T>
class SelfDrivable : public T
{
    ...
};

SelfDrivable<Car> selfDrivableCar
SelfDrivable<Truck> selfDrivableTruck
```

이렇게 쓰라고 한다. 믹스인 자체는 32장에서 자세히 쓴다고 한다.

**1-3. 집계 방식으로 논리적 개념 나누기**

집계는 `has-a` 를 의미한다. 서로 관련이 없거나 있어도 상속만으론 분리가 어려운 경우 사용가능하다.

예를 들어 가족관계를 나타내는 `Family` 클래스가 있다고 하자. 트리 구조로 나타날텐데, 이걸 `Family` 에 직접 구현하지 말고 `Tree` 자체를 구현하면 자료구조 재사용이 가능해진다.

`Family`와 `Tree`는 `Has-a`관계가 된다.

**1-4. 사용자 인터페이스에 대한 종속성 제거하기**

데이터를 조작하거나 관리하는 라이브러리는 터미널 I/O와 직접적인 연관이 있으면 안된다.

예를 들어서 `sqlite3` 라는 DB가 있는데, 여기에 해당하는 `CRUD` 동작은 싹다 라이브러리 형태로 제공된다.

근데 이 내부에서 에러가 났다고 터미널에 에러를 찍어주지 않는다. API의 에러코드로 리턴이 된다.

이렇듯 사용자의 인터페이스와 내부 동작과는 분리를 해주어야 한다.

마찬가지로 GUI 기반의 앱도 내부 동작이 외부 GUI에 어떤 형태로 메세지를 출력할지를 정해선 안된다.

#### 6.2.2.2 범용 데이터 구조와 알고리즘을 템플릿으로 구현하기

템플릿을 통해 범용 데이터 타입을 받을 수 있다.

```c++
vector<int> veci;
vector<double> vecd;
```

템플릿 직접 정의는 12 / 26장에서 더 본다고 함;

설계 관점에서 중요한것만 짚고 넘어간다.

* 프로그램 자체에 특화된게 아닌 범용적으로 설계하는 것이 좋다.
* 이진 트리를 예로 들면, 어떤 타입의 데이터라도 트리에 넣을 수 있어야 한다.
  * 이건 표준라이브러리가 기똥차게 만들어놨다.

**2-1. 템플릿이 다른 제네릭 프로그래밍 테크닉보다 나은 이유**

사실 `void*` 를 쓰면 c던 c++던 범용 타입이 가능하다. 하지만 이건 타입 안전성이 떨어진다. (`타입 세이프` 하지 않음).

타입세이프한 코드는 컴파일타임에 다 잡을 수 있어서 좋음

`void*` 대용으로 c++17에 `std::any` 가 추가되었다고 함. 나중에 설명하니 알아만 두어라. 내부 구현에서 `void*` 를 쓰는데, 원래 타입을 내부에 저장해놓기 때문에 타입 안전성을 보장해놓을 수 있는 방법이라캄.

범용 타입을 모두 허용하는 방법 **말고**, 범용적인 객체 하나를 정의하고, 해당 객체를 모두 상속하는 방법도 유용하다.

Java의 `Object` 가 그렇다. Java는 모든 객체가 `Object`를 자동으로 상속함. 다만 이건 타입 안전성을 보장할 수 없음. 원래 타입을 알고있다가 다운캐스팅할 방법이 없기 때문. => 물론 제네릭이라고 하는 기능이 있다. (템플릿 비슷한거임)

템플릿은 제대로만 사용하면 타입 안전성이 보장되니까 좋다.

**2-2. 템플릿의 단점**

* 문법이 복잡하다.
* 타입이 섞일 수 없다.
  * 예를 들어, int와 double 데이터가 한 `balanced-tree` 에 들어갈 순 없다.
  * 마찬가지로 c++ 17에 std::variant, std::any 같은 방법으로 우회가능하다함
* 코드가 비대해진다.

**2-3. 템플릿과 상속**

둘 중 어떤걸 사용할 지 헷갈릴 수 있다.

* 동일한 기능을 다양한 타입에 사용하면 **템플릿**
  * 범용 타입 자료구조 생성.
  * ex) Vector / RBTree / etc..
* 특정 타입마다 동작을 다르게 제공해야 하면 **상속**
  * 예) 삼각 / 사각 / 오각형 별 넓이를 구한다. => `Shape` 클래스에서 상속받아 만들기

#### 6.2.2.3 적절한 검사 기능과 안전 장치 제공하기.

두 가지 스타일이 있다. 적절히 섞어 써라.

1. 계약에 따른 설계 (`Design by contract`)

특정 클래스를 개발한 개발자와 해당 코드를 사용하는 클라이언트 간의 계약이라고 보면 된다. 크게 **선행조건**, **후행조건**, **불변조건** 이 있다고 한다.
* 선행조건
  * 함수나 메서드 호출 전 클라이언트가 해놔야 하는거
* 후행조건
  * 함수나 메서드의 실행이 끝날 때 반드시 만족해야 할 조건
* 불변조건
  * 함수나 메서드 실행 과정에서 항상 만족해야할 조건

`std::vector` 를 예로 들자. `std::vector`는 배열 접근법으로 접근이 가능하다는 `선행조건`이 있다. 따라서 `std::vector`가 가리키는 위치의 원소가 유효한 지에 대한 경계값 검사는 클라이언트가 해야한다.

2. 함수나 클래스를 최대한 안전하게 설계

에러 검사를 수행하는 것이 가장 중요하다. 앞서 말한 배열식 접근법에서 `std::vector`는 `at()` 라는 메소드도 제공한다. 여기선 경계값 검사를 포함한 접근을 허용해주어, 경계값을 벗어날 경우 `Exception`을 던져준다.

[ 회계사 예시 ]

회계사는 지난 1년간의 재무 정보를 받아 국세청 양식에 맞게 세무신고를 해준다.

회계사는 양식에 데이터를 입력할 때 기계식으로 다 적는게 아니라, 해당 정보가 **맞는 지부터 확인**할것이다. 한 해 수입이 1500이고 1200을 월세로 냈으면 이걸 확인할 것이다.

회계사는 `프로그램` 우리의 재무정보는 `입력` 환급 새액은 `출력` 이라고 할 수 있겠다.

회계사는 여기서 그치지 않고, 세금 신고 과정까지 모니터링해서 오류가 없는 지도 확인해주며, 에러 처리 없이 세금 신고가 끝날때까지 동작한다.

#### 6.2.2.4. 확장성을 고려한 설계

클래스 설계 시엔, 상속해서 확장할 수 있도록 **개방**적임과 동시에 수정이 불가능하게 **폐쇄**적이여야 한다.


```c++
class Square {
    // 구현적인 내용을 생략한다.
};

class Renderer {
public:
    void render(const vector<Square>& squares) {
        for (auto& square : squares) {
            // square 객체를 렌더링한다.
        }
    }
};
```
여기에 circle에 대한 render를 추가한다 하자

```c++
class Circle {
    // 구현적인 내용을 생략한다.
};

void Renderer::render(const vector<Square>& squares,
                      const vector<Circle>& circles) {
    for (auto& square : squares) {
        // square 객체를 렌더링한다.
    }
    for (auto& circle : circles) {
        // circle 객체를 렌더링한다.
    }
}

```
벌써 render 함수에 인자가 추가되어서 코드가 지저분해진다.

```c++
class Shape {
public:
    virtual void render() = 0;
};

class Square : public Shape {
public:
    virtual void render() override {
        // 사각형을 렌더링한다.
    }
};

class Circle : public Shape {
public:
    void render() override {
        // 원을 렌더링한다.
    }
};

class Renderer {
public:
    void render(const vector<Shape*>& objects) {
        for (auto& object : objects) {
            object->render();
        }
    }
};
```

이런 식으로 `Shape`별로 `render`를 구현하여 렌더러에는 `Shape`들을 쭉 `vector` 형태로 전달만 하면 렌더러 수정 없이 객체를 자유롭게 추가할 수 있다.

### 6.2.3 사용성 높은 인터페이스 설계

*인터페이스*가 형편없으면 추상화랑 구조화가 무쓸모.

* 언제든 재사용할 수 있기 때문에 인터페이스 설계는 중요
* 다른 사람도 쓰니까

**c++ 인터페이스는 결국 어떤 항목을 public 처리할 지가 관건**

#### 6.2.3.1 사용자 고려하기

누가 쓸지를 알아야함. 나만 ? 회사사람? 외부사람?
 결국 이 인터페이스를 어떤 사람들이 나한테 와서 물어볼건지 생각하면 편함.

나만 쓴다면 설계까지 막 바꿔도 되지만, 다른 사람과 인터페이스 설계를 마쳤다면, 이건 일종의 **계약서**인 셈이다.

이 때 다른 이들이 필요로하는 기능들, `버전관리`나 `데이터타입` 등을 고려해야 한다.

외부 고객이라면 여기에서 더 나아가, 공개여부도 신중하게 정해야 하고, 변수, 메소드 이름도 간결하게 정해야함.

#### 6.2.3.2 용도 고려하기

코드를 문서화하거나 외부에 노출할 기능을 정하기 이전에 인터페이스의 용도를 확실히 해야한다.

** 1. API? **

제품의 기능을 다양한 용도로 활용하거나, 제품의 기능을 확장하기 위해 외부로 제공하는 인터페이스.

API를 설계함에 있어서 가장 중요한건 `사용성`과 `유연성` 사이의 절충점을 찾는 것이다. 사용하는 이들은 내부 작동 방식을 모를꺼라, API의 사용법을 쉽게 익히도록 구성해야 한다.

제품이 여기저기 적용될 수 있게 유연성을 높이면 API가 복잡해져서 사용성이 떨어진다.

** 2. 유틸리티 클래스와 라이브러리 **

로깅 클래스 같은 특정한 기능을 애플리케이션에서 범용적으로 사용할 수 있도록 해야될 때가 있음.

이 경우 `범용성` 관점만 고려하면 됨

** 3. 서브시스템 인터페이스 **

어플리케이션을 구성하는 주요 서브시스템 (DB나 웹 FE 등)를 연동할 때에 사용되는 인터페이스도 고려해야 한다. 이 때 인터페이스와 구현을 **명확하게 분리**하는 것이 중요하다.

* **모형성**(Mockability)
    * 실제 데이터베이스에 연결하지 않고도 인터페이스에 대한 테스트 코드를 쓸 수 있어야 함.
    * 주로 웹 BE에서 웹 FE화면 없이도 이를 모킹화 해가지고 테스트를 많이 함.
* **유연성**(Flexability)
    * 서브시스템이 바뀔 수 있음
    * 예를 들어, DB를 MySQL에서 SQL Server나 Oracle로 바꾼다고 하면, 인터페이스 입구는 그대로 두고도 구현만 갈아치기해도 되는 경우가 많다.
* 서브시스템을 다룰 땐 항상 이 서브시스템의 핵심 목적을 분명히 해야한다.
  * 활용 사례를 먼저 따지고 어떤 형태로 제공할지 고민하도록

** 4. 컴포넌트 인터페이스 **

가벼운거라고 함. 똑같은 얘기 계속하니 패스

#### 6.2.3.3 인터페이스를 사용하기 쉽게 설계하기

** 1. 익숙한 방식 따르기 **

사용자에게 익숙한 표준을 따라라.

`c++`에 익숙한 사용자에겐 `c++` 표준 기반의 인터페이스를 제공하는게 좋다. 예를들어 생성 / 소멸자에 있어서, `c++`사용자는 객체를 완전 생성하고 완전히 제거한다고 생각할 것이다. 이것에 맞게 인터페이스와 구현을 개발해야 한다.

또한 **연산자 오버로딩** 을 사용하면 훨씬 쉽게 만들 수 있다.

** 2. 필요한 기능 빼먹지 않기 **

1. 클라이언트가 필요로 하는 동작을 모두 인터페이스에 추가하는 것.
   * 가능한 경우들을 최대한 고려해서 추가시켜라.
2. 인터페이스에 최대한 많은 기능을 구현하는 것
   * 라이브러리 내에서 해결이 가능한건 클라이언트에게 보여선 안된다.
   * 가령 `mktemp`처럼 만든 임시파일을 사용할 때 이 정보가 굳이 사용자한테 보일 필요는 없다.

또한 클라이언트가 어떤 결과를 취합하고자 할 때 이걸 클라이언트에게 시키면 안된다. 이에 해당하는 기능을 제공하는게 맞다.

** 3. 군더더기 없는 인터페이스 제공하기 **

* 쓸데없는 기능은 빼라
* 작게 만들수록 유지보수가 편함

** 4. 문서와 주석 제공하기 **

유닉스는 대부분 `man` 명령어를 치면 메뉴얼이 제공된다. 이렇듯 메뉴얼 제공을 해줘라.

```bash
> man ls
LS(1)               User Commands               LS(1)

NAME
       ls - list directory contents

SYNOPSIS
       ls [OPTION]... [FILE]...

DESCRIPTION
       List  information about the FILEs (the current
       directory by default).  Sort entries alphabet‐
       ically if none  of  -cftuvSUX  nor  --sort  is
       specified.

       Mandatory arguments to long options are manda‐
       tory for short options too.

       -a, --all
              do not ignore entries starting with .

       -A, --almost-all
              do not list implied . and ..

       --author
```

#### 6.2.3.4 범용 인터페이스 설계

** 1. 하나의 기능을 다양한 방식으로 실행하게 만들기 **

이 원칙을 남용하면 인터페이스가 산만해지니까 주의

자동차 열쇠를 예로들면 보통 리모컨. 하지만 방전을 방지하기 위해 수동방법도 제공

`vector` 도 `배열식 접근` 과 `at`을 통한 접근 두 방법을 제공한다. 경계값 검사 유무에 따라 속도 차이가 있는 방식들이다. 이건 사용자가 적절하게 선택해서 확인하면 된다.

** 2. 커스터마이즈 지원하기 **

로그를 생각하면, 언제든 로그레벨을 동적으로 조절할 수 있는 기능을 지원해야 한다. 즉 클라이언트의 능력에 따라 약간 **변형**해서 사용할 수 있도록 선택권을 제공해야 한다.

이 커스터마이즈의 가장 대표적인게 **의존성 역전 원칙**(DIP) 의 일종으로 생각하면 좋다.

표준 라이브러리를 생각하면, 사용자가 `Allocator`를 지정해서 `vector` 등에 설정할 수 있다. 이런 의존관계를 설정해놓으면 사용자가 얼마든지 표준 라이브러리를 커스텀 할 수가 있는 것이다.

#### 6.2.3.5 범용성과 사용성의 조화

범용성과 사용성은 충돌할 때가 많다. 범용성을 높이면 사용성이 떠?ㄹ어지기 때문.

이 둘을 잘 조화롭게 사용할 수도 있다.

**인터페이스 분리 원칙**이라고 부르는데, 인터페이스를 다양하게 제공하는 기능이라 보면 된다.

네트워킹 인터페이스를 예로 들면, 하나는 `http` 프로토콜에 유리한 네트워킹 인터페이스 기능을 제공하고, 다른 하나는 `ftp`같은 파일전송 프로토콜에 유리한 네트워킹 인터페이스 기능을 제공하여 기능별로 인터페이스를 분리할 수 있다. 이러면 범용성도 지키고 사용성도 어느정도 지킬 수 있긴 하다.

### 6.2.4 바람직한 추상화 설계

**끊임없이 개선한다** 큰 내용은 없음

### 6.2.5 솔리드 원칙

객체지향의 Solid 원칙을 잘 기억하자.

| SOLID | 설명                                                                                     |
|-------|------------------------------------------------------------------------------------------|
| **S** | **SRP (Single Responsibility Principle, 단일 책임 원칙)**<br>컴포넌트마다 한 가지 책임을 잘 정의하고 관련없는 기능을 합치지 않는다. |
| **O** | **OCP (Open/Closed Principle, 개방/폐쇄 원칙)**<br>클래스는 (상속을 통해) 확장에는 개방적이고, 수정에는 폐쇄적이어야 한다. |
| **L** | **LSP (Liskov Substitution Principle, 리스코프 치환 원칙)**<br>어떤 객체의 인스턴스를 그 객체의 서브타입 인스턴스로 치환(대체)할 수 있어야 한다.<br>5.4.3절 'has-a 관계'와 'is-a 관계 구분하기'에서 **AssociativeArray**와 **MultiAssociativeArray**의 관계를 has-a로 봐야할지 is-a로 봐야할지 예제를 통해 소개했다. |
| **I** | **ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**<br>인터페이스는 깔끔하고 간결해야 한다.<br>거대한 범용 인터페이스보다는 작지만 한 가지 책임이라도 잘 정의된 인터페이스를 여러 개로 구성하는 것이 낫다. |
| **D** | **DIP (Dependency Inversion Principle, 의존성 역전 원칙)**<br>인터페이스로 의존 관계를 역전시킨다.<br>한 가지 방법으로 앞서 언급한 의존성 주입 원칙이 있다.<br>보다 자세한 사항은 33장에서 설명한다. |

## 6.3 정리

**작성은 한번 사용은 여러번** 이라는 기본 철학에서 재사용 관점에서 코드 설계법을 나열해봄

재사용을 위한 추상화 방법과 코드 설계법을 봤고, 이 때 인터페이스에 대해 설계하는 방법을 얘기했다. (구현은 당근 사용자의 몫)

## 6.4 연습 문제

### 6.4.1 공통적으로 사용되는 기능을 더욱 쉽게 만들고, 동시에 고급 기능에 대한 옵션도 제공한다는 말이 무슨 뜻인지 생각해보자.

인터페이스 학습 자체가 쉬워야 함과 동시에, 충분히 다양한 기능을 제공해야 한다?

책의 답:
```
Making the common case easy and the unlikely case possible means that your interfaces should have a simple learning curve. The things that most programmers will want to do should be accessible. However, the interfaces should allow for more advanced and less likely usage, and it's acceptable to trade off complexity of the rare case for simplicity of the common case.
```

### 6.4.2 재사용 가능한 코드 설계를 위한 최선의 전략은?

서로 관련 없거나 논리적으로 구분되는 개념을 합쳐줘야 하고, 범용 데이터 구조와 알고리즘을 템플릿으로 구현해야 한다. 또한 적절한 검사기능과 안전 장치를 제공해야 하고, 확장성까지 고려해야 함. (그냥 6.2.2.#의 제목 나열 )

책의 답:
```
The single most important strategy for reusable code design is abstraction.

When you design code, you should clearly separate the interface from the implementation. This separation makes the code easier to use, primarily because clients do not need to understand the internal implementation details in order to use the functionality.

Abstraction separates code into interfaces and implementation, so designing reusable code focuses on these two main areas. First, you must structure the code appropriately. What class hierarchies will you use? Should you use templates? How should you divide the code into subsystems?
Second, you must design the interfaces, which are the "entries" into your library, or code that programmers use, to access the functionality you provide.
```

### 6.4.3 문제는 하단
* 문제
  * 사람에 대한 정보를 다루는 애플리케이션
  * 최근 주문 목록, 우수 회원 번호와 같은 데이터<=>고객 간 연계 데이터를 유지
  * 직원ID, 직함 으로 직원기록도 관리해야함
  * 이를 위헤 Person이라는 클래스에 아래와 같은 속성들을 추가함
    * 전화번호, 주소, 최근 주문 목록, 우수 회원 번호, 연봉, 직원ID, 직함
  * 문제가 뭐고 개선방안이 뭘까?

* 내 대답
  * 추상화가 적절히 이루어지지 않았다. 애초에 위에 목록은 Person 항목에 넣을게 전화번호랑 주소 뿐인듯.
  * 아래와 같이 구조를 나누고, 메소드도 적절히 처리한다.

```bash
        +----------------+
        |   Person       | - 전화번소 / 주소
        +----------------+
               ^
               |
     +---------+---------+
     |                   |
+----------------+   +----------------+
|      Worker    |   |   Client       |
+----------------+   +----------------+
 직원 ID               우수 회원 번호
 연봉                  최근 주문 목록
 직함
```

### 6.4.4 SOLID 안보고 대답하기.

일단 난 못함

