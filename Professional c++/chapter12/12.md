- [12. 템플릿으로 제네릭 코드 만들기](#12-템플릿으로-제네릭-코드-만들기)
  - [12.1 템플릿 소개](#121-템플릿-소개)
  - [12.2 클래스 템플릿](#122-클래스-템플릿)
    - [12.2.1 클래스 템플릿 작성법](#1221-클래스-템플릿-작성법)
      - [12.2.1.1 템플릿 없이 구현한 GameBoard 클래스](#12211-템플릿-없이-구현한-gameboard-클래스)
      - [12.2.1.2 템플릿으로 구현한 Grid 클래스](#12212-템플릿으로-구현한-grid-클래스)
        - [12.2.1.2.1 Grid 클래스 정의](#122121-grid-클래스-정의)
        - [12.2.1.2.2 Grid 메소드 정의](#122122-grid-메소드-정의)
        - [12.2.1.2.3 Grid 템플릿 사용법](#122123-grid-템플릿-사용법)
    - [12.2.2 컴파일러에서 템플릿을 처리하는 방식](#1222-컴파일러에서-템플릿을-처리하는-방식)
      - [12.2.2.1 선택적 인스턴스화](#12221-선택적-인스턴스화)
      - [12.2.2.2 템플릿에 사용할 타입의 조건](#12222-템플릿에-사용할-타입의-조건)
    - [12.2.3 템플릿 코드를 여러 파일에 나누기](#1223-템플릿-코드를-여러-파일에-나누기)
      - [12.2.3.1 클래스 템플릿 정의에 메소드 정의 함께 적기](#12231-클래스-템플릿-정의에-메소드-정의-함께-적기)
      - [12.2.3.2 메소드 정의를 다른 파일에 적기](#12232-메소드-정의를-다른-파일에-적기)
    - [12.2.4 템플릿 매개변수](#1224-템플릿-매개변수)
      - [12.2.4.1 비타입 템플릿 매개변수](#12241-비타입-템플릿-매개변수)
      - [12.2.4.2 타입 매개변수의 디폴트 값](#12242-타입-매개변수의-디폴트-값)
      - [12.2.4.3 생성자에 대한 템플릿 매개변수의 유추 과정](#12243-생성자에-대한-템플릿-매개변수의-유추-과정)
        - [12.2.4.3.1 사용자 정의 유추 방식](#122431-사용자-정의-유추-방식)
    - [12.2.5 메서드 템플릿](#1225-메서드-템플릿)
      - [12.2.5.1 비타입 매개변수를 사용하는 메서드 템플릿](#12251-비타입-매개변수를-사용하는-메서드-템플릿)
    - [12.2.6 클래스 템플릿의 특수화](#1226-클래스-템플릿의-특수화)
    - [12.2.7 클래스 템플릿 상속하기.](#1227-클래스-템플릿-상속하기)
    - [12.2.8 상속과 특수화 비교](#1228-상속과-특수화-비교)
    - [12.2.9 앨리어스 템플릿](#1229-앨리어스-템플릿)
    - [12.3 함수 템플릿](#123-함수-템플릿)
      - [12.3.1 함수 템플릿 오버로딩](#1231-함수-템플릿-오버로딩)
      - [12.3.2 클래스 템플릿의 프렌드 함수 템플릿](#1232-클래스-템플릿의-프렌드-함수-템플릿)
      - [12.3.3 템플릿 매개변수 유추에 대한 보충 설명](#1233-템플릿-매개변수-유추에-대한-보충-설명)
      - [12.3.4 함수 템플릿의 리턴 타입](#1234-함수-템플릿의-리턴-타입)
      - [12.3.5 축약 함수 템플릿 구문](#1235-축약-함수-템플릿-구문)
      - [12.4 변수 템플릿](#124-변수-템플릿)
    - [12.5 콘셉트](#125-콘셉트)
      - [12.5.1 문법](#1251-문법)
      - [12.5.2 제약 표현식](#1252-제약-표현식)
        - [12.5.2.1 요구 표현식](#12521-요구-표현식)
          - [단순 요구사항](#단순-요구사항)
          - [타입 요구사항](#타입-요구사항)
          - [복합 요구사항](#복합-요구사항)
          - [중첩 요구사항](#중첩-요구사항)
        - [12.5.2.2 콘셉트 표현식 조합하기](#12522-콘셉트-표현식-조합하기)
      - [12.5.3 미리 정의된 표준 콘셉트](#1253-미리-정의된-표준-콘셉트)
      - [12.5.4 auto 타입 제약조건 지정하기](#1254-auto-타입-제약조건-지정하기)
      - [12.5.5 타입 제약조건과 함수 템플릿](#1255-타입-제약조건과-함수-템플릿)
        - [12.5.5.1 제약 조건 포함 관계](#12551-제약-조건-포함-관계)
      - [12.5.6 타입 제약 조건과 클래스 템플릿](#1256-타입-제약-조건과-클래스-템플릿)
      - [12.5.7 타입 제약 조건과 클래스 메소드](#1257-타입-제약-조건과-클래스-메소드)
      - [12.5.8 타입 제약 조건과 템플릿 특수화](#1258-타입-제약-조건과-템플릿-특수화)


# 12. 템플릿으로 제네릭 코드 만들기

> 제네릭 프로그래밍?
>
> 하나의 데이터 타입에 의존하지 않고 하나의 값이 여러 데이터 타입을 가질 수 있는 것에 중점을 두어
> 코드의 재사용성을 높이는 기법
>
> 출처: [제네릭 프로그래밍 위키피디아](https://ko.wikipedia.org/wiki/%EC%A0%9C%EB%84%A4%EB%A6%AD_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

## 12.1 템플릿 소개

절차형 프로그래밍에서 `sqrt` 와 같은 함수 구현을 할 때, 정수형 제곱근들에 대해서만 구현을 한다고 하면 특정 `값`에 대해서만 종속될 것이다.

예를 들어

```c++
int sqrt_array[] = {1, 4, 9, 16, ... };

int sqrt(int value) {
    if ( sqrt_array.contains(value) ) {
        return getSqrt(value);
    }
    return -1;
}
```

의 식으로 `값`에 대해서만 구현이 가능하다.

당연히 이런 방식은 효율이 떨어지므로, 정수형을 넘어 모든 유리수에 대해서 `sqrt` 구현이 제공된다.

이렇게 `매개변수`에 지정한 모든 `값`에 대해서 함수를 구현하는걸 `매개변수화`라고 한다.

여기서 `값`이라는 범위를 넘어 `타입`에 대해서도 지정한 모든 `타입`들에 대해 `매개변수화`할 수가 있다.

이걸 제네릭 프로그래밍이라고 한다고 보면되고, c++에선 이걸 `템플릿`형태로 제공한다.

## 12.2 클래스 템플릿

`클래스 템플릿`은
* 멤버 변수의 타입
* 메서드의 리턴 타입
* 메서드의 매개변수 타입

등을 매개변수로 받아서 클래스에 정의한다. 이 절에서는 `Grid` 클래스를 생성하면서 이부분을 공부한다.

### 12.2.1 클래스 템플릿 작성법

체스게임이나 체커게임등에서 보드(`Grid`)를 모두 공용으로 사용하려면 최대한 범용적으로 클래스를 구현해야 함.

#### 12.2.1.1 템플릿 없이 구현한 GameBoard 클래스

만약 `GameBoard` 에서 사용할 `GamePiece` 라는 Class가 있었다고 하자.

여기서 체스 게임을 구현한다고 할 때, `GamePiece` 에 대한 복사본 등을 생성하는 메서드인 `clone` 함수를 아래와 같이 볼 수 있다.

```c++
export class GamePiece
{
public:
    virtual ~GamePiece() = default;
    virtual std::unique_ptr<GamePiece> clone() const = 0; // 순수 가상함수. 상속받은 곳에서 반드시 구현해야 함.
};
```

`ChessPiece` 에선 체스게임만의 규칙등이 적용될 수 있으므로, 가상함수형태이고 상속받은 함수 내에서 더 구체적으로 구현이 가능하다.

```c++
class ChessPiece : public GamePiece
{
public:
    std::unique_ptr<GamePiece> clone() const override
    {
        // 복제 생성자로 이 인스턴스를 복제한다.
        return std::make_unique<ChessPiece>(*this);
    }
};
```

`GameBoard` 에 대한 구현을 보면 아래와 같다.

```c++
export class GameBoard
{
public:
    explicit GameBoard(size_t width = DefaultWidth,
                       size_t height = DefaultHeight);

    /* 아래 두개는 구현해야함 ! */
    GameBoard(const GameBoard& src); // 복제 생성자
    GameBoard& operator=(const GameBoard& rhs); // 대입 연산자

    virtual ~GameBoard() = default;  // 가상 디폴트 소멸자

    // 이동 생성자와 이동 대입 연산자를 명시적으로 디폴트로 지정한다.
    GameBoard(GameBoard&& src) = default;
    GameBoard& operator=(GameBoard&& src) = default;

    // Reference로 리턴함.
    std::unique_ptr<GamePiece>& at(size_t x, size_t y);
    const std::unique_ptr<GamePiece>& at(size_t x, size_t y) const;

    size_t getHeight() const { return m_height; }
    size_t getWidth() const { return m_width; }

    static const size_t DefaultWidth { 10 };
    static const size_t DefaultHeight { 10 };

    void swap(GameBoard& other) noexcept;

private:
    void verifyCoordinate(size_t x, size_t y) const;

    std::vector<std::vector<std::unique_ptr<GamePiece>>> m_cells;
    size_t m_width { 0 }, m_height { 0 };
};

export void swap(GameBoard& first, GameBoard& second) noexcept;
```

`at` 함수를 보면 `const`객체에서만 호출할 수 있는 `const`전용 `at`함수가 있고, 일반 객체에서 참조자에 대해 컨트롤이 가능한 `at`함수 두 가지 버전을 제공함.

멤버함수들의 구현은 아래와 같다.

```c++
GameBoard::GameBoard(size_t width, size_t height)
    : m_width{width}, m_height{height}
{
    m_cells.resize(m_width);
    for (auto& column : m_cells) {
        column.resize(m_height);
    }
}

GameBoard::GameBoard(const GameBoard& src)
    : GameBoard{src.m_width, src.m_height}
{
    // 여기 나온 생성자 초기값은 메모리를 적절한 크기로 할당하는 작업을
    // 비복제 생성자에 위임한다.

    // 그리고 나서 데이터를 복제한다.
    /* 아까 생성한 clone을 쓰는걸 알 수 있음 */
    for (size_t i{0}; i < m_width; i++) {
        for (size_t j{0}; j < m_height; j++) {
            if (src.m_cells[i][j])
                m_cells[i][j] = src.m_cells[i][j]->clone();
        }
    }
}

void GameBoard::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= m_width) {
        throw out_of_range{format("{} must be less than {}.", x, m_width)};
    }
    if (y >= m_height) {
        throw out_of_range{format("{} must be less than {}.", x, m_height)};
    }
}

void GameBoard::swap(GameBoard& other) noexcept
{
    std::swap(m_width, other.m_width);
    std::swap(m_height, other.m_height);
    std::swap(m_cells, other.m_cells);
}

void swap(GameBoard& first, GameBoard& second) noexcept
{
    first.swap(second);
}

GameBoard& GameBoard::operator=(const GameBoard& rhs)
{
    // 복제 후 멱법규칙
    GameBoard temp{rhs}; // 모든 작업을 임시 인스턴스로 처리한다.
    swap(temp);          // non-throwing 연산으로만 작업 결과를 반영한다.
    return *this;
}

const unique_ptr<GamePiece>& GameBoard::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return m_cells[x][y];
}

unique_ptr<GamePiece>& GameBoard::at(size_t x, size_t y)
{
    return const_cast<unique_ptr<GamePiece>&>(as_const(*this).at(x, y));
}

```

```c++
GameBoard chessBoard{8, 8};
auto pawn{std::make_unique<ChessPiece>()}; // GameBoard 타입의 Vector 멤버변수 타입들이 std::unique_ptr<GamePiece>
chessBoard.at(0, 0) = std::move(pawn); // 이동 대입 연산자.
chessBoard.at(0, 1) = std::make_unique<ChessPiece>(); // 복사 대입 연산자.
chessBoard.at(0, 1) = nullptr; // 소멸. 소유권 말소.
```

#### 12.2.1.2 템플릿으로 구현한 Grid 클래스

위 코드의 문제는 두가지.
* 변수들을 모두 포인터 타입으로 저장해야 하는 문제
* `ChessPiece`의 기능을 사용하기 위해선 `dynamic_cast`로 다운캐스팅하지 않으면 안된다.
* 반드시 `GamePiece`를 상속한 타입만 사용이 가능함.

따라서 타입별로 구현이 가능한 `제네릭 프로그래밍`이 사용되어야 한다.

```c++
class TicTacToePiece : public GamePiece
{
public:
    std::unique_ptr<GamePiece> clone() const override
    {
        // 복제 생성자를 호출해서 이 인스턴스를 복제한다.
        return std::make_unique<TicTacToePiece>(*this);
    }
};
```
위와 같이 `GamePiece` 에 대한 추가 타입이 있다고 할 때
```c++
GameBoard chessBoard{8, 8};
chessBoard.at(0, 0) = std::make_unique<ChessPiece>();
chessBoard.at(0, 1) = std::make_unique<TicTacToePiece>();
```
의 구조에서 타입을 기억하지 않으면 `다운캐스팅` 시 치명적인 에러가 발생할 것이다.

##### 12.2.1.2.1 Grid 클래스 정의

다형성(`Template`)을 이용하려면 아무래도 포인터보단 값 그 자체를 쓰는게 좋다.

Grid에선 이렇게 구현할 것이다.

다만 포인터 전달방식이 아니라 값전달로 바꾸게 되면 실제 `vector`내에 모든 데이터가 들어가있어야 함.

따라서 초기회된 어떤 값을 `Template` 별로 만들어야 하는 문제가 있음

이를 방어하기 위해 `c++17`의 `optional<T>`를 사용할 것임.

> optional<T> ?
>
> 쓰면 좋긴한데, 값의 유무를 판단하기 위한 플래그비트정도는 추가된다고 함.
> value_or 같이 접근함

```c++
export template <typename T>
class Grid
{
public:
    explicit Grid(size_t width = DefaultWidth,
                  size_t height = DefaultHeight);
    virtual ~Grid() = default;

    // 복제 생성자와 대입 연산자를 명시적으로 디폴트로 지정한다.
    Grid(const Grid& src) = default;
    Grid& operator=(const Grid& rhs) = default;

    // 이동 생성자와 대입 연산자를 명시적으로 디폴트로 지정한다.
    Grid(Grid&& src) = default;
    Grid& operator=(Grid&& rhs) = default;

    std::optional<T>& at(size_t x, size_t y);
    const std::optional<T>& at(size_t x, size_t y) const;

    size_t getHeight() const { return m_height; }
    size_t getWidth() const { return m_width; }

    static const size_t DefaultWidth{10};
    static const size_t DefaultHeight{10};

private:
    void verifyCoordinate(size_t x, size_t y) const;

    std::vector<std::vector<std::optional<T>>> m_cells; // optional 사용.
    size_t m_width{0}, m_height{0};
};
```
한줄씩 살펴보자.
```c++
export template <typename T>
```
여기서 `template`과 `typename`은 모두 c++ 스페셜 키워드.

> typename?
>
> class라는 이름으로 대체도 되는데, class를 쓰면 사용자가 느끼기에 class만 써야된다고 느낄 수 있음.
>
> 하지만 사실 struct, 기본 타입 등 아무거나 써도됨. 따라서 typename 권장.


```c++
Grid(const Grid& src) = default;
Grid& operator=(const Grid& rhs) = default;
```

이전 버전은 복사생성 / 복사대입연산 모두에 대해 구현을 했어야함.

하지만 지금은 그럴 필요가 없다. 기존엔 결국 공간이 추가로 필요한 것이었고 (`unique_ptr`), 현재는 값이 들어갈 공간은 이미 존재하기 때문에

기본 복사생성 / 복사대입연산 만으로 충분하다.

```c++
Grid<T>& operator=(const Grid<T>& rhs) = default;
```

클래스의 정의 내에선 위와같이 `<T>`를 명시적으로 달아주지 않아도 알아서 연역해서 가져간다.

하지만 클래스 정의 밖에선 `Grid<T>`라고 명시적으로 붙여줘야 하는데, 그 이유는 `Grid` 자체는 `템플릿 명` 이기 때문.

템플릿에 들어오는 타입 별로 클래스 자체가 인스턴스화 될텐데, 이에 대한 이름이 필요한 클래스 바깥에선 `Grid<T>`로 표현해야된다는 뜻이다.


```c++
// Reference로 리턴함.
/* GameBoard 버전 */
std::unique_ptr<GamePiece>& at(size_t x, size_t y);
const std::unique_ptr<GamePiece>& at(size_t x, size_t y) const;

/* Grid 버전 */
std::optional<T>& at(size_t x, size_t y);
const std::optional<T>& at(size_t x, size_t y) const;
```

더이상 포인터가 아닌 `optional<T>`값을 저장하므로, 이에 대한 레퍼런스 리턴을 하면 된다.

##### 12.2.1.2.2 Grid 메소드 정의

```c++
template <typename T>
Grid<T>::Grid(size_t width, size_t height)
    : m_width{width}, m_height{height}
{
    m_cells.resize(m_width);
    for (auto& column : m_cells) {
        column.resize(m_height);
    }
}
```

* 단순히 Vector공간만 있으면 됨. `resize()`
* 클래스 정의 바깥에서 위와같이 메소드를 정의할 수 있다.
* 앞서 설명한대로 클래스 정의를 벗어났으므로 `Grid`가 아닌 `Grid<T>`인거다.
* 반드시 템플릿 메소드들은 모든 `T`에 대해 처리가 가능한 형태로 구현되어야 한다.
* 일반적으로 클래스 정의 바로 아래에 그냥 같은 파일에 작성을 해버린다고 한다.
  * 따로 나눠서 작성하는 기법은 다른 장에서 설명함

```c++
template <typename T>
void Grid<T>::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= m_width) {
        throw std::out_of_range{
            std::format("{} must be less than {}.", x, m_width)};
    }
    if (y >= m_height) {
        throw std::out_of_range{
            std::format("{} must be less than {}.", y, m_height)};
    }
}

template <typename T>
const std::optional<T>& Grid<T>::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return m_cells[x][y];
}

template <typename T>
std::optional<T>& Grid<T>::at(size_t x, size_t y)
{
    return const_cast<std::optional<T>&>(
        std::as_const(*this).at(x, y));
}
```

볼만한건 `비 const`의 `at` 메소드.

이미 잘 정의된 `const` 객체용 `at`함수에 대한 재사용을 하기 좋음.

현재 `비 const`객체를 `const`화 해서 기존에 구현한 `const`용 `at` 메소드를 호출하고

해당 메소드의 리턴에 대해 `const`를 제거하는 `const_cast`로 리턴해버림.

죄다 컴파일 타임에 일어나는 일이니까 사실 구현하는거랑 큰 차이는 없는데, 코드 중복방지에 용이한듯.

> T{} ?
>
> 위 코드엔 안나오는데, 이렇게 하면 클래스는 기본 생성자, 기본타입은 모두 0을 초기화로 사용한다함
>
> 영초기화라 불린다함.

##### 12.2.1.2.3 Grid 템플릿 사용법

```c++
Grid<int> myIntGrid; // int 값을 저장할 Grid 객체를 선언한다.
// 이때 생성자에 디폴트 인수를 적용한다.

Grid<double> myDoubleGrid{11, 11}; // double 값에 대한 11x11 Grid 선언

myIntGrid.at(0, 0) = 10;
int x{myIntGrid.at(0, 0).value_or(0)}; // optional에서 제공하는 놈. 있으면 값 없으면 0

Grid<int> grid2{myIntGrid}; // 복제 생성자
Grid<int> anotherIntGrid;
anotherIntGrid = grid2; // 대입 연산자
```

다 필요없고, 실제 사용할때는 `Template`에 걸맞는 타입을 넣으라는 얘기

인스턴스화 된 이후에는 실제론 각각의 별개 클래스랑 동일하므로 해당 매개변수를 사용하는 함수에서도

```c++
void processInt(Grid<int> grid);
```
와 같이 써야된다는 뜻.

```c++
using intGrid = Grid<Int>;
```
같이 정의해놓고 써도됨

아래는 `Grid`템플릿 사용의 다양한 예

```c++
Grid<SpreadsheetCell> mySpreadsheet;
SpreadsheetCell myCell{1.234};
mySpreadsheet.at(3, 4) = myCell;

// 다음처럼 포인터 타입 객체도 저장할 수 있다.
Grid<const char*> myStringGrid;
myStringGrid.at(2, 2) = "hello";

// 심지어 다른 템플릿 타입을 지정할 수도 있다.
Grid<vector<int>> gridOfVectors;
vector<int> myVector{1, 2, 3, 4};
gridOfVectors.at(5, 6) = myVector;

// Grid 템플릿 인스턴스화를 통해 객체를 프리스토어에 동적으로 생성할 수도 있다.
auto myGridOnHeap{make_unique<Grid<int>>(2, 2)}; // 프리스토어에 2x2 Grid 생성
myGridOnHeap->at(0, 0) = 10;
int x{myGridOnHeap->at(0, 0).value_or(0)};
```

### 12.2.2 컴파일러에서 템플릿을 처리하는 방식

컴파일러는 템플릿을 정의하는 코드만 봤을때는 단순히 템플릿에 대한 문법검사만 수행한다.

그리고 실제로 컴파일 하다가 `Grid<int>`나 `Grid<UserClass>`의 코드를 봤을 때만 실제 제네릭에 대한 인스턴스화를 수행한다.

단순히 단어바꾸기 작업을 수행하는 것이라고 생각하면 된다.

따라서 특정 타입에 대한 (`UserClass`) 인스턴스화를 전혀 해놓지 않으면 컴파일은 되지 않는다.

#### 12.2.2.1 선택적 인스턴스화

컴파일러는 아래와 같은 `암묵적인 클래스 템플릿 인스턴스화`를 보면 (그냥 `Grid<Int>` 같은거)

해당 인스턴스화된 클래스에 대한 `가상 메소드 코드`만 생성한다.

```c++
Grid<int> myIntGrid;
```

그럼 다른 메소드들은 언제 컴파일이 되냐? 실제 사용을 하는 놈들만 컴파일해서 코드영역에 저장한다.

```c++
Grid<int> myIntGrid;
myIntGrid.at(0, 0) = 10;
```

의 코드가 있으면,
* 영인수생성자
* 소멸자
* 비 const at()

만 컴파일하고, 복사생성이나 대입연산, `getHeight`같은 코드들은 컴파일하지 않는다.

이를 `선택적 인스턴스화`라고 한다

문제는 이러면 컴파일이 되지 않기때문에 실제로 템플릿 메소드 내에 에러가 있어도 사용을 안했다는 이유로 발견을 못할 수가 있다.

따라서 `명시적 클래스 템플릿 인스턴스화`를 할수가 있다. 구문에러 찾는데 도움이 된다.

```c++
template Grid<int>;
```

이건 근데 기본타입 말고 `string`같은 복잡한 타입에다가 써서 에러를 찾으라고 한다.

#### 12.2.2.2 템플릿에 사용할 타입의 조건

템플릿 클래스, 메소드 내에서 `T`에 해당하는 인스턴스 대상 타입이 원하는 연산을 지원하지 않으면 당연히 컴파일 에러다.

다만 앞에서 언급했듯이 사용을 안하면 컴파일이 안되니까 이런걸 우회할 순 있다.

`c++20`에선 `콘셉트`라는게 나와서 템플릿 인수에 대해 요구조건을 명시할 수가 있다.

이를 통해 컴파일타임에 이런저런 에러를 잡기가 용이해짐. 뒤에 설명

### 12.2.3 템플릿 코드를 여러 파일에 나누기

#### 12.2.3.1 클래스 템플릿 정의에 메소드 정의 함께 적기

메소드 정의 코드를 템플릿 정의코드에 같이 적으면 이 모듈을 임포트하는 곳에서 모든 메소드들에 대한 정의도 같이 임포트된다.

#### 12.2.3.2 메소드 정의를 다른 파일에 적기

```c++
export module grid;

export import :definition;
export import :implementation;

// 이렇게 하면 두 모듈 파티션(definition과 implementation)을 임포트하고 익스포트한다.
// 이 클래스 템플릿 정의는 definition 파티션에 정의된다.
```

```c++
export module grid:definition;

import <vector>;
import <optional>;
export template <typename T> class Grid { ... };
```

```c++
export module grid:implementation;

import :definition;
import <vector>;
...
export template <typename T>
Grid<T>::Grid(size_t width, size_t height)
    : m_width{width}, m_height{height}
{ ... }
```

위와 같이 모듈별로 따로 구현을 해서 `클래스 정의` 파트 `메소드 정의`파트를 모두 나누고,
이를 `grid`모듈로 묶어서 배포하면 된다.

### 12.2.4 템플릿 매개변수

```c++
template<typename T>
```
위와 같은 형태로 타입에 대한 템플릿을 나열했는데, 함수의 매개변수 리스트와 마찬가지로 여러 개 둘 수 있다.

타입 대신 디폴트 값을 둘 수도 있다.

#### 12.2.4.1 비타입 템플릿 매개변수

비타입 매개변수(`non-type parameter`)란 `int`나 `포인터`처럼 일반 함수에서 사용하는 매개변수 타입을 말한다.

* 정수형 값 (int, char, bool 등)
* 열거형 값 (enum)
* 포인터 (int*, 함수 포인터 등)
* 참조 (int&)
* std::nullptr_t
* 멤버 포인터 (int MyClass::*)
* 사용자 정의 타입(class type, C++20부터)
* std::integral_constant (C++20에서 일반화된 상수 표현)

가 있다.

`부동소수점` 들은 왜 안되는가?

```c++
#include <iostream>

template<double Value>
struct FloatingPointTemplate {
    static constexpr double getValue() {
        return Value;
    }
};

int main() {
    FloatingPointTemplate<3.14> piInstance;
    FloatingPointTemplate<2.718> eInstance;
    FloatingPointTemplate<0.3> tmp1;
    FloatingPointTemplate<0.1 + 0.2> tmp2;

    std::cout << "Pi: " << piInstance.getValue() << std::endl;  // 출력: 3.14
    std::cout << "E: " << eInstance.getValue() << std::endl;    // 출력: 2.718

    return 0;
}
```
`c++20`부턴 된다고 하는데 제약사항이 많다.

위에서 `tmp1`과 `tmp2`간에는 근사치로인한 차이가 분명 존재할거고 별개의 인스턴스화가 진행되는게 맞다.

따라서 애초에 이런걸 안쓰는게 낫고 책에서도 다루진 않음.

```c++
export template <typename T, size_t WIDTH, size_t HEIGHT>
class Grid
{
public:
    Grid() = default;
    virtual ~Grid() = default;

    // 복제 생성자와 대입 연산자를 명시적으로 디폴트로 지정한다.
    Grid(const Grid& src) = default;
    Grid& operator=(const Grid& rhs) = default;

    std::optional<T>& at(size_t x, size_t y);
    const std::optional<T>& at(size_t x, size_t y) const;

    size_t getHeight() const { return HEIGHT; }
    size_t getWidth() const { return WIDTH; }

private:
    void verifyCoordinate(size_t x, size_t y) const;

    std::optional<T> m_cells[WIDTH][HEIGHT];
};
```
`WIDTH`, `HEIGHT` 를 애초에 받아버리고 인스턴스화를 바로 할 수 있다.

이러면 컴파일타임에 연산들이 모두 예상외 되므로 `vector`같은 동적 자료구조가 아닌 컴파일타임에 처리가 가능한 `2차원 배열` 화가 가능하다.

아래는 메소드 구현이다. 큰 차이는 없다.

```c++
template <typename T, size_t WIDTH, size_t HEIGHT>
void Grid<T, WIDTH, HEIGHT>::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= WIDTH) {
        throw std::out_of_range{
            std::format("{} must be less than {}.", x, WIDTH)};
    }
    if (y >= HEIGHT) {
        throw std::out_of_range{
            std::format("{} must be less than {}.", y, HEIGHT)};
    }
}

template <typename T, size_t WIDTH, size_t HEIGHT>
const std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return m_cells[x][y];
}

template <typename T, size_t WIDTH, size_t HEIGHT>
std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(size_t x, size_t y)
{
    return const_cast<std::optional<T>&>(
        std::as_const(*this).at(x, y));
}
```

사용은 아래와 같다.

여기서 첫 번째 제약사항을 확인할 수 있다. 비타입 템플릿 매개변수로 정수형을 사용할 때 반드시 상수를 사용해야 한다.

```c++
Grid<int, 10, 10> myGrid;
Grid<int, 10, 10> anotherGrid;
myGrid.at(2, 3) = 42;
anotherGrid = myGrid;
cout << anotherGrid.at(2, 3).value_or(0);

// 첫 번째 제약은 높이와 너비로 사용할 정수를 상수로 지정해야 한다.
size_t height{10};
Grid<int, 10, height> testGrid; // 컴파일 에러 발생.

// height를 상수로 정의하면 문제없이 컴파일된다.
const size_t height{10};
Grid<int, 10, height> testGrid; // 컴파일 성공
```
따라서 아래와 같이 컴파일타임에 모든 값을 계산할 수 있도록 `constexpr`화 할 수 있다.
```c++
constexpr size_t getHeight() { return 10; }
...
Grid<double, 2, getHeight()> myDoubleGrid;
```

두 번째 제약은 좀 크리티컬한데, 당연한거지만 비타입 템플릿 매개변수로

```c++
Grid<double, 10, 10> myDoubleGrid1;
Grid<double, 10, 11> myDoubleGrid2;
```
와 같이 사용하면 아예 다른 `Grid` 타입의 변수들이 생성된다는 것이다.

당연히 타입이 다르다 판단하여 서로 호환도 안된다.

#### 12.2.4.2 타입 매개변수의 디폴트 값

클래스 템플릿 생성 시 디폴트 값을 지정할 수 있다.
```c++
export template <typename T = int, size_t WIDTH = 10, size_t HEIGHT = 10>
class Grid
{
    // 나머지 코드는 이전과 같다.
};
```

메소드 템플릿에 대해서는 따로 값을 지정하지 않아도 괜찮다.

`const 객체`용 `at` 함수 구현예시는 아래와 같다.
```c++
template <typename T, size_t WIDTH, size_t HEIGHT>
const std::optional<T>& Grid<T, WIDTH, HEIGHT>::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return m_cells[x][y];
}
```

사용은 아래와 같이 할 수 있다.
```c++
Grid<> myIntGrid;
Grid<int> myGrid;
Grid<int, 5> anotherGrid;
Grid<int, 5, 5> aFourthGrid;

// 참고로 클래스 템플릿 매개변수를 모두 생략하더라도 꺾쇠괄호는 반드시 적어야 한다.
// 예를 들어 다음과 같이 작성하면 컴파일 에러가 발생한다.
Grid myIntGrid; // 컴파일 에러
```

#### 12.2.4.3 생성자에 대한 템플릿 매개변수의 유추 과정

컴파일러는 `CTAD`(Class Template Argument Deduction) 를 이용하여 클래스 템플릿 생성자에 전달된 인수를 보고 템플릿 매개변수를 알아낸다.

`CTAD`는 c++17 이상부터 쓸 수 있음.

원래라면 아래와 같이 써야한다.
```c++
pair<int, double> pair1{1, 0.1};
auto pair2 = std::make_pair(1, 0.1); // Pair 생성자 내에 전달된 인수를 보고 어떤 인스턴스(템플릿 Class)를 호출할지 알아서 정함
pair pair3{1, 0.1}; // 생성자 인수를 보고 알아서 추론을 해감. c++17 이상
pair pair4; // 당근 안됨
```

> unique_ptr, shared_ptr에 대한 CTAD
>
> 얘네는 타입 추론 기능이 꺼져있음.
>
> 생성자에 T* 를전달하면 컴파일러는 <T> 랑 <T[]> 중에 하나를 선택해야 하는데, 잘못선택하면 망할 수 있음
>
> make_shared, make_unique를 명시적으로 그냥 써라.

##### 12.2.4.3.1 사용자 정의 유추 방식

```c++
template <typename T>
class SpreadsheetCell
{
public:
    SpreadsheetCell(T t) : m_content{move(t)} { }
    const T& getContent() const { return m_content; }

private:
    T m_content;
};
```
의 `SpreadsheetCell` 클래스가 있을 때

```c++
string myString{"Hello World!"};
SpreadsheetCell cell{myString};
```

와 같이 사용하면, `myString`이 `const char*`로 연역이 되어버리는 상황이 발생한다.

이걸 방지하기 위해서 아래와 같이 추론하도록 만들 수 있다.
```c++
//explicit은 생략 가능
(explicit) SpreadsheetCell(const char*) -> SpreadsheetCell<std::string>;
```

이건 반드시 클래스 정의 바깥에다가 적어야 한다. (`c++ 17`)

### 12.2.5 메서드 템플릿

클래스 뿐만아니라 클래스 내 메서드를 템플릿화 할 수 있는데, 이러면 한 메서드를 다양한 타입에 대해 매칭시킬 수 있다.

> Caution
>
> virtual 메소드 및 소멸자는 템플릿화가 불가능하다.

아래와 같은 두 Grid를 보자.
```c++
Grid<int> myIntGrid;
Grid<double> myDoubleGrid;
```

두 `Grid`는 다른 타입이므로 복제가 불가능하다.
```c++
myDoubleGrid = myIntGrid; // 컴파일 에러 발생
Grid<double> newDoubleGrid{myIntGrid}; // 컴파일 에러 발생
```

왜냐면 복제생성자는 아래와 같이 정의되어있기 때문이다.
```c++
Grid(const Grid& src);
Grid& operator=(const Grid& rhs);
=
Grid(const Grid<T>& src);
Grid<T>& operator=(const Grid<T>& rhs);
```
복제 생성자와 Grid의 대입 연산자인 operator=는 모두 const Grid<T>& 레퍼런스를 인수로 받는다.

따라서 위 코드처럼 `double`을 받으려면
```c++
Grid(const Grid<double>& src);
Grid<double>& operator=(const Grid<double>& rhs);
```
처럼 타입별로 따로 만들어줘야 하는 수고스러움이 있다. 이를 해결하려면 `typename`을 하나 더 두면 된다.


아래는 변경된 `Grid` 클래스 정의이다.
```c++
export template <typename T>
class Grid
{
public:
    template <typename E> // 추가 type
    Grid(const Grid<E>& src); // 복사 생성자

    template <typename E> // 추가 type
    Grid<T>& operator=(const Grid<E>& rhs); // 복사 대입 연산자.

    void swap(Grid& other) noexcept;

    // 코드 생략
};
```
// 먼저 템플릿 버전으로 수정한 복제 생성자부터 살펴보자.
```c++
// 코드 예제
template <typename T> // 클래스에는 단일 템플릿 타입만 사용함
template <typename E> // 메소드에서 사용되는 타입이 추가로 있다는 의미
// template <typename T, typename E> => 이건 클래스 자체에 템플릿이 2개 들어갈 경우 사용하는 방법이라 함
Grid<T>::Grid(const Grid<E>& src)
    : Grid{src.getWidth(), src.getHeight()}
{
    // 이 생성자가 제공한 가장 먼저 메모리를 적절히 할당하는 작업을
    // 비복제 생성자에 위임한다.
    // 그리고 나서 데이터를 복제한다.
    for (size_t i{0}; i < m_width; i++) {
        for (size_t j{0}; j < m_height; j++) {
            m_cells[i][j] = src.at(i, j);
        }
    }
}
```

주석에도 써놨지만 아래와 같이 쓰면 안됨
```c++
template <typename T, typename E>
Grid<T>::Grid(const Grid<E>& src); // 중첩된 템플릿 생성자를 이렇게 적으면 안 된다.
```
swap 구현은 아래와 같다.
```c++
// swap() 메서드는 다음과 같이 구현한다.
template <typename T>
void Grid<T>::swap(Grid<T>& other) noexcept
{
    std::swap(m_width, other.m_width);
    std::swap(m_height, other.m_height);
    std::swap(m_cells, other.m_cells);
}
```

복사 대입은 아래와 같다.
```c++
template <typename T>
template <typename E>
Grid<T>& Grid<T>::operator=(const Grid<E>& rhs)
{
    // 복제 후 멱법규칙 구문
    Grid<T> temp{rhs};   // 모든 작업을 임시 인스턴스에서 처리한다.
    swap(temp);          // 예외가 발생하지 않는 연산에 대해서만 말끔하다.
    return *this;
}
```

추가로 책에 T랑 E가 같은 경우에 복사 생성이 안된다고 나와있는데, 무슨 말인질 모르겠음. 실제로 해보면 잘 됨.

뒷내용 포함해서 생각해보면 실제론 구분이 되는 메소드라는 의미로 받아들여야 할듯.

#### 12.2.5.1 비타입 매개변수를 사용하는 메서드 템플릿

```c++
export template <typename T, size_t WIDTH = 10, size_t HEIGHT = 10>
class Grid
{
public:
    Grid() = default;
    virtual ~Grid() = default;

    // 복제 생성자와 대입 연산자를 명시적으로 디폴트로 지정한다.
    // 소멸자를 지정했으므로 쩔수다.
    // 근데 없어도 잘만 돌거같다.
    Grid(const Grid& src) = default;
    Grid<T, WIDTH, HEIGHT>& operator=(const Grid& rhs) = default;

    /* 같은 복사생성자와 복사 대입 연산자지만, 위의 default와 동작차이가 있으므로 override의 개념으로 봐야된다. */
    template <typename E, size_t WIDTH2, size_t HEIGHT2> // 메서드용 템플릿 인자 추가
    Grid(const Grid<E, WIDTH2, HEIGHT2>& src);

    template <typename E, size_t WIDTH2, size_t HEIGHT2> // 메서드용 템플릿 인자 추가
    Grid& operator=(const Grid<E, WIDTH2, HEIGHT2>& rhs);

    void swap(Grid& other) noexcept;

    std::optional<T>& at(size_t x, size_t y);
    const std::optional<T>& at(size_t x, size_t y) const;

    size_t getHeight() const { return HEIGHT; }
    size_t getWidth() const { return WIDTH; }

private:
    void verifyCoordinate(size_t x, size_t y) const;

    std::optional<T> m_cells[WIDTH][HEIGHT];
};

// 템플릿화된 복제 생성자를 정의하는 코드
template <typename T, size_t WIDTH, size_t HEIGHT>
template <typename E, size_t WIDTH2, size_t HEIGHT2>
Grid<T, WIDTH, HEIGHT>::Grid(const Grid<E, WIDTH2, HEIGHT2>& src)
{
    for (size_t i{0}; i < WIDTH; i++) {
        for (size_t j{0}; j < HEIGHT; j++) {
            if (i < WIDTH2 && j < HEIGHT2) {
                m_cells[i][j] = src.at(i, j);
            } else {
                m_cells[i][j].reset();
            }
        }
    }
}

template <typename T, size_t WIDTH, size_t HEIGHT>
void Grid<T, WIDTH, HEIGHT>::swap(Grid& other) noexcept
{
    std::swap(m_cells, other.m_cells);
}

template <typename T, size_t WIDTH, size_t HEIGHT>
template <typename E, size_t WIDTH2, size_t HEIGHT2>
Grid<T, WIDTH, HEIGHT>& Grid<T, WIDTH, HEIGHT>::operator=(
    const Grid<E, WIDTH2, HEIGHT2>& rhs)
{
    // 복제 후 멱법규칙 구문
    Grid<T, WIDTH, HEIGHT> temp{rhs}; // 모든 작업을 임시 인스턴스에서 처리한다.
    swap(temp);                       // 예외가 발생하지 않는 연산에 대해서만 말끔하다.
    return *this;
}
```
### 12.2.6 클래스 템플릿의 특수화

전체를 모두 템플릿화 할 수 있지만

`const char*` 와 같은 타입에 있어서 특정한 메소드들만 `string`으로 처리하는 등의 동작을 수행하고 싶을 수 있다.

그럴 때 사용하는게 클래스 템플릿의 특수화 이다.

```c++
export module grid:string;
// 템플릿 특수화를 적용할 때 원본 템플릿도 반드시 참조할 수 있어야 한다.
import :main;

/* 여기서부터 보면 됨 */
export template <>
class Grid<const char*> // const char* 타입에 대해서만 특수화한다.
{
public:
    explicit Grid(size_t width = DefaultWidth,
                  size_t height = DefaultHeight);
    virtual ~Grid() = default;

    // 복제 생성자와 대입 연산자를 명시적으로 디폴트로 선언한다.
    Grid(const Grid& src) = default;
    Grid& operator=(const Grid& rhs) = default;

    // 이동 생성자와 대입 연산자를 명시적으로 디폴트로 선언한다.
    Grid(Grid&& src) = default;
    Grid& operator=(Grid&& rhs) = default;

    /* 아래 템플릿 2개를 특수화하려고 쓰는거라고 보면 됨. */
    std::optional<std::string>& at(size_t x, size_t y);
    const std::optional<std::string>& at(size_t x, size_t y) const;

    size_t getHeight() const { return m_height; }
    size_t getWidth() const { return m_width; }

    static const size_t DefaultWidth{10};
    static const size_t DefaultHeight{10};

private:
    void verifyCoordinate(size_t x, size_t y) const;

    /* 데이터에 대한 저장도 가변으로 처리하려고 string으로 받는다 */
    std::vector<std::vector<std::optional<std::string>>> m_cells;
    size_t m_width{0}, m_height{0};
};
```

```c++
export template <>
class Grid<const char*> // const char* 타입에 대해서만 특수화한다.
```

이렇게 해놓으면 특수화된 템플릿이라는걸 컴파일러가 인지할 수 있다.

또한 템플릿 프로그래밍 자체를 깨트리지 않고도 프로그래밍을 할 수 있는 장점이 있다.

`const char*`에 대한 인스턴스화 시에 모두 `string`으로 특수처리된 함수를 쓸 것이고, 사용자는 이에대해 몰라도 된다.

상속이랑은 전혀 다른 개념이다. 정의부터 다시하는걸 보면 알 수 있다시피 상속이 없고, **클래스 전체에 대해 새로 프로그래밍 해야한다.**

템플릿 메소드 구현은 아래와 같고, 타입이 정해져 있으므로 `template, typename`같은 스페셜 키워드는 없어도 된다.

```c++
Grid<const char*>::Grid(size_t width, size_t height)
    : m_width{width}, m_height{height}
{
    m_cells.resize(m_width);
    for (auto& column : m_cells) {
        column.resize(m_height);
    }
}

void Grid<const char*>::verifyCoordinate(size_t x, size_t y) const
{
    if (x >= m_width) {
        throw std::out_of_range{
            std::format("{} must be less than {}.", x, m_width)};
    }
    if (y >= m_height) {
        throw std::out_of_range{
            std::format("{} must be less than {}.", y, m_height)};
    }
}

const std::optional<std::string>& Grid<const char*>::at(size_t x, size_t y) const
{
    verifyCoordinate(x, y);
    return m_cells[x][y];
}

std::optional<std::string>& Grid<const char*>::at(size_t x, size_t y)
{
    return const_cast<std::optional<std::string>&>(
        std::as_const(*this).at(x, y));
}

```

부분 특수화에 대해선 26장에서 다룬다.

### 12.2.7 클래스 템플릿 상속하기.

```c++
import grid;

export template <typename T>
class GameBoard : public Grid<T>
{
public:
    explicit GameBoard(size_t width = Grid<T>::DefaultWidth,
                       size_t height = Grid<T>::DefaultHeight);
    void move(size_t xSrc, size_t ySrc, size_t xDest, size_t yDest);
};
```

동적할당을 사용하지 않으니 추가적인 생성자를 구현할필요가 없고, 필요한 메소드인 `move`정도만 추가하면 됨.

`T`에 대한 제네릭 타입마다 별개로 상속받기 때문에 기존 상속 문법과 동일함

```c++
template <typename T>
GameBoard<T>::GameBoard(size_t width, size_t height)
    : Grid<T>{width, height}
{
}

template <typename T>
void GameBoard<T>::move(size_t xSrc, size_t ySrc, size_t xDest, size_t yDest)
{
    Grid<T>::at(xDest, yDest) = std::move(Grid<T>::at(xSrc, ySrc));
    Grid<T>::at(xSrc, ySrc).reset(); // 원본 셀을 리셋한다.
    // 이 부분을 다음과 같이 구현해도 된다.
    // this->at(xDest, yDest) = std::move(this->at(xSrc, ySrc));
    // this->at(xSrc, ySrc).reset();
}

/* 사용 */
GameBoard<ChessPiece> chessboard{8, 8};
ChessPiece pawn;
chessboard.at(0, 0) = pawn;
chessboard.move(0, 0, 0, 1);
```

### 12.2.8 상속과 특수화 비교

| 속성       | 상속  |특수화|
|------------|-------------------------------------------------------------------------|--------|
| 코드 재사용 | O: 파생 클래스는 베이스 클래스에 있는 데이터 멤버와 메서드를 모두 받는다.   |X: 특수화를 할 때는 필요한 코드를 모두 다시 작성해야 한다.|
| 이름 재사용 | X: 파생 클래스의 이름은 반드시 베이스 클래스와 다르게 지어야 한다.         |O: 특수화 템플릿 클래스의 이름은 반드시 원본과 같아야 한다. |
| 다형성 지원 | O: 파생 클래스의 객체를 베이스 클래스의 객체로 포함할 수 있다.            |X: 템플릿을 인스턴스화한 결과마다 타입이 다르다.  |


### 12.2.9 앨리어스 템플릿

```c++
/* 일반적인 alias */
using MyInt = int;

/* 타입 alias의 다른 예 */
template <typename T1, typename T2>
class MyClassTemplate { /* ... */ };
using OtherName = MyClassTemplate<int, double>;

/* alias template 라 불리는 것. 템플릿까지 alias화를 할 수 있음. */
template <typename T1>
using OtherName = MyTemplateClass<T1, double>;
```

### 12.3 함수 템플릿

```c++
static const size_t NOT_FOUND{static_cast<size_t>(-1)};

template <typename T>
size_t Find(const T& value, const T* arr, size_t size)
{
    for (size_t i{0}; i < size; i++) {
        if (arr[i] == value) {
            return i; // 값을 찾으면 인덱스를 리턴한다.
        }
    }
    return NOT_FOUND; // 값을 찾지 못하면 NOT_FOUND를 리턴한다.
}
```
위는 함수 템플릿의 예

```c++
int myInt{3}, intArray[]{1, 2, 3, 4};
const size_t sizeIntArray{size(intArray)};

/* 함수 템플릿 호출 예 */
size_t res;
res = Find(myInt, intArray, sizeIntArray); // 추론해서 Find<int>를 호출한다.
res = Find<int>(myInt, intArray, sizeIntArray); // Find<int>를 명시적으로 호출한다.

if (res != NOT_FOUND) { cout << res << endl; }
else { cout << "Not found" << endl; }

double myDouble{5.6}, doubleArray[]{1.2, 3.4, 5.7, 7.5};
const size_t sizeDoubleArray{size(doubleArray)};

// 타입을 추론해서 Find<double>을 호출한다.
res = Find(myDouble, doubleArray, sizeDoubleArray);
// Find<double>을 명시적으로 호출한다.
res = Find<double>(myDouble, doubleArray, sizeDoubleArray);
if (res != NOT_FOUND) { cout << res << endl; }
else { cout << "Not found" << endl; }

// res = Find(myInt, doubleArray, sizeDoubleArray);
// 위와 같이 작성하면 컴파일 에러가 발생한다. 인수의 타입이 서로 다르기 때문이다.
// myInt가 double로 암시적으로 Find<double>을 호출한다.
res = Find<double>(myInt, doubleArray, sizeDoubleArray);

SpreadsheetCell cell1{10};
SpreadsheetCell cellArray[]{SpreadsheetCell{4}, SpreadsheetCell{10}};
const size_t sizeCellArray{size(cellArray)};

res = Find(cell1, cellArray, sizeCellArray);
res = Find<SpreadsheetCell>(cell1, cellArray, sizeCellArray);
```

비타입 매개변수를 넣은 버전도 사용이 가능하다.
```c++
template <typename T, size_t N>
size_t Find(const T& value, const T(&arr)[N])
{
    return Find(value, arr, N);
}

int myInt{3}, intArray[]{1, 2, 3, 4};
size_t res{Find(myInt, intArray)};
```

#### 12.3.1 함수 템플릿 오버로딩

아래와 같이 `const char*` 같은 특수한 타입에는 특별히 다른 방식으로 구현해야 하는 경우도 있을 걳임

```c++
size_t Find(const char* value, const char** arr, size_t size)
{
    for (size_t i{0}; i < size; i++) {
        if (strcmp(arr[i], value) == 0) {
            return i; // 값을 찾으면 인덱스를 리턴한다.
        }
    }
    return NOT_FOUND; // 찾지 못하면 NOT_FOUND를 리턴한다.
}
```

```c++
const char* word{"two"};
const char* words[]{"one", "two", "three", "four"};
const size_t sizeWords{size(words)};
size_t res{Find(word, words, sizeWords)}; // 템플릿이 아닌 일반 Find() 호출

// 템플릿 타입 매개변수를 다음과 같이 명시적으로 지정하면 함수 템플릿은
// const char*에 대해 오버로드한 버전이 아닌 T=const char*에 대해 호출된다.
res = Find<const char*>(word, words, sizeWords); // 이렇게 하면 arr[i] == value 코드가 불리는 것
```

#### 12.3.2 클래스 템플릿의 프렌드 함수 템플릿

함수 템플릿은 클래스 템플릿의 연산자 오버로딩을 할 때 유용함

예를 들어 `operator +` 에 대해 보겠음.

```c++
// 더 작은 녀석의 크기만큼 덧셈 수행
export template <typename T>
Grid<T> operator+(const Grid<T>& lhs, const Grid<T>& rhs)
{
    size_t minWidth{std::min(lhs.getWidth(), rhs.getWidth())};
    size_t minHeight{std::min(lhs.getHeight(), rhs.getHeight())};

    Grid<T> result{minWidth, minHeight};
    for (size_t y{0}; y < minHeight; ++y) {
        for (size_t x{0}; x < minWidth; ++x) {
            const auto leftElement{lhs.m_cells[x][y]};
            const auto rightElement{rhs.m_cells[x][y]};
            if (leftElement.has_value() && rightElement.has_value()) {
                result.at(x, y) = leftElement.value() + rightElement.value();
            }
        }
    }
    return result;
}

// Grid 템플릿에 대한 전역 선언
export template <typename T> class Grid;

// 템플릿화된 operator+에 대한 프로토타입
export template <typename T>
Grid<T> operator+(const Grid<T>& lhs, const Grid<T>& rhs);

// 함수 템플릿가 클래스 템플릿을 이어주는 역할
// <T>를 명시적으로 붙이는게 중요하다.
export template <typename T>
class Grid
{
public:
    friend Grid operator+<T>(const Grid<T>& lhs, const Grid<T>& rhs);
    // 코드 생략
};
```

`friend` 화를 해줌으로써 `at`과 같이 public 메소드로 접근하지 않아도 된다.

#### 12.3.3 템플릿 매개변수 유추에 대한 보충 설명

```c++
template <typename RetType, typename T1, typename T2>
RetType add(const T1& t1, const T2& t2) { return t1 + t2; }

auto result{add<long, long, int, int>(1, 2)};

// 함수 매개변수들은 알아서 추론해갈 수 있다. 리턴만 지정하는 방법
auto result{add<long long>(1, 2)};

// 물론 매개변수 리스트에서 마지막에 있는 매개변수만 추론할 수 있다. 예를 들어 함수 템플릿에
// 다음과 같이 정의된 경우를 살펴보자.
template <typename T1, typename RetType, typename T2>
RetType add(const T1& t1, const T2& t2) { return t1 + t2; }

// 여기에서는 RetType을 자동으로 추론할 수 없기 때문에 명시적으로 지정해야 한다. 그러면
// RetType이 두 번째 매개변수에 있기 때문에 T1도 명시적으로 지정해야 한다.
auto result{add<int, long, long>(1, 2)};


// 디폴트 타입까지 정해주면 아무것도 안써도 됨
template <typename RetType = long long, typename T1, typename T2>
RetType add(const T1& t1, const T2& t2) { return t1 + t2; }
...
auto result{add(1, 2)};
```

#### 12.3.4 함수 템플릿의 리턴 타입

```c++
template <typename T1, typename T2>
RetType add(const T1& t1, const T2& t2) { return t1 + t2; }

/* c++ 14부턴 컴파일러가 연역하도록 auto로 리턴이 가능 */
template <typename T1, typename T2>
auto add(const T1& t1, const T2& t2) { return t1 + t2; }
```

auto를 이렇게 쓰면 const 지정자나 reference가 사라진다.

이걸 살리려면 `decltype` 을 명시적으로 붙여줘야 한다.

우선 아래와 같은 명시적인 함수가 있다고 치자.
```c++
const std::string message{"Test"};
const std::string& getString() { return message; }
```

getString()을 호출한 결과를 auto 타입 변수에 저장할 수 있다.

const는 사라졌기 때문에 복사연산이 발생한다 보면 됨
```c++
auto s1{getString()};
```

const, 레퍼런스를 쓰고싶으면 아래와 같이 사용한다.
```c++
const auto& s2{getString()};
```

decltype 예는 아래와 같다. 이러면 const나 reference가 사라지지 않음

```c++
decltype(getString()) s3{getString()}; // type= const string&
```

```c++
decltype(auto) s4{getString()}; // 코드 중복 제거 버전
```

이제 auto와 decltype에 대해 알았으니 앞서 설명한 add() 함수 템플릿으로 돌아가자. 이번 예제는 add()에서 const와 레퍼런스 지정자가 사라지지 않도록 decltype(t1+t2)로 지정했다.

c++14 이상만 가능한기법. decltype(auto)가 그때부터 지원됨.
```c++
template <typename T1, typename T2>
decltype(auto) add(const T1& t1, const T2& t2) { return t1 + t2; }
```

Expresion 부분에 아래와 같이 적으면 안된다. 프로토 타입 시작 부분에 t1, t2를 적어도 타입이 해석되지 못함.
```c++
template <typename T1, typename T2>
decltype(t1+t2) add(const T1& t1, const T2& t2) { return t1 + t2; }
```

trailing return syntax 라고 해서 이전에는 추론 방법을 뒤에 적어줌으로써 연역이 되도록 했다.

```c++
template <typename T1, typename T2>
auto add(const T1& t1, const T2& t2) -> decltype(t1+t2)
{
    return t1 + t2;
}
```

#### 12.3.5 축약 함수 템플릿 구문

c++ 20에 추가됨

```c++
template <typename T1, typename T2>
decltype(auto) add(const T1& t1, const T2& t2) { return t1 + t2; }

// 아래와 같이 표현이 가능
decltype(auto) add(const auto& t1, const auto& t2) { return t1 + t2; }
```

`Template` 구문 자체가 없다. 모두 `auto`화

주의할 점이 2가지 있다.

1. 서로 다른 템플릿 매개변수라는 점.

```c++
template <typename T>
decltype(auto) add(const T& t1, const T& t2) { return t1 + t2; }
```
이건 템플릿 매개변수가 모두 `T`로 하나인데, 위의 `auto`버전은 각각의 t1, t2에 대한 타입이 서로 다르게 추론된다.

이 때문에 인스턴스화가 매우 많이 발생할 수 있음

2. 추론된 타입을 명시적으로 사용할 수 없음.

decltype(auto)에 의존해야 한다.


#### 12.4 변수 템플릿

```c++
template <typename T>
constexpr T pi{3.141592653589793238462643383279502884};

float piFloat{pi<float>};
auto piLongDouble{pi<long double>};
```

T 별로 인스턴스화된건 각기 다른 타입이름이라 가능한듯?

### 12.5 콘셉트

타입 매개변수와 템플릿 타입 등을 제한하는데 사용되는 기능

#### 12.5.1 문법
* `constraints-expression` ?
  * 상수 표현식만 올 수 있다.
  * 컴파일 시간이 평가될 수 있는 모든 표현식을 지정할 수 있다.
  * 이 표현식의 결과는 반드시 부울이어야함
  * 실행 시간에는 평가되지 않는다.
```c++
template <parameter-list>
concept concept-name = constraints-expression;
```


#### 12.5.2 제약 표현식

콘셉트를 통해 제약으로 사용할 수 있음
```c++
template <typename T>
concept C = sizeof(T) == 4;
```

##### 12.5.2.1 요구 표현식

요구 표현식 문법은 아래와 같음

```c++
requires (parameter-list) { requirements; }
```

`parameter-list` 는 생략해도 된다고 한다. `requirements`는 세미콜론(`;`) 로 구분해야 함

단순 타입 복합 중첩 총 4가지의 요구사항이 있다고 함

###### 단순 요구사항

requires로 시작하지 않는 표현식

```c++
template <typename T>
concept Incrementable = requires(T x) { x++; ++x; };
```

이건 T라는 타입이 선행, 후항 증가연산자에 대해 제공을 해야된다는걸 필요조건으로 요구한다고 보면 됨

###### 타입 요구사항

아래는 T라는 타입에 `value_type`이라는 멤버가 존재해야한다.
```c++
template <typename T>
concept C = requires { typename T::value_type; };
```

인스턴스화가 가능한지도 검사할 수 있다.
```c++
template <typename T>
concept C = requires { typename SomeTemplate<T>; };
```

###### 복합 요구사항
익셉션을 제대로 던지는 지, 리턴이 올바른지를 정할 수 있다.

문법은 아래와 같음
```c++
{ expression } noexcept -> type-constraint;
```

noexcept와 -> type-constraint는 둘 다 옵션이다. 예를 들어 다음과 같이 작성한 콘셉트는 주어진 타입에 swap()이란 메서드가 있으며 noexcept로 지정되었는지 검사한다.
```c++
template <typename T>
concept C = requires (T x, T y) {
    { x.swap(y) } noexcept;
};
```

아래는 좀 더 복잡한 시나리오 들인데, x에 `size`라는 메서드가 있는 지를 검사함과 동시에 리턴 타입이 `size_t`로 변환이 가능한지 검사를 한다.
```c++
template <typename T>
concept C = requires (const T x) {
    { x.size() } -> convertible_to<size_t>;
};
```
아래는 비교연산자들이 가능한 지, 리턴타입이 잘 나오는지 검사하는것
```c++
template <typename T>
concept Comparable = requires (const T a, const T b) {
    { a == b } -> convertible_to<bool>;
    { a < b } -> convertible_to<bool>;
    // 다른 비교 연산자에 대해서도 비슷하게 명시한다.
};
```

###### 중첩 요구사항

요구사항들을 중첩해서 사용할 수 있다.

타입 크기가 4바이트여야 하고, 선/후행 증/감 연산자를 모두 지원해야 함을 명시할 수 있다.
```c++
template <typename T>
concept C = requires (T t) {
    requires sizeof(t) == 4;
    ++t; --t; t++, t--;
};
```

##### 12.5.2.2 콘셉트 표현식 조합하기

이미 정한 콘셉트 표현식을 조합해서 (&, |) 표현할 수 있다고 함

Incrementable<T>,  Decrementable<T> 두개 다 미리 정의한 콘셉트의 이름이어야 함.
```c++
template <typename T>
concept IncrementableAndDecrementable = Incrementable<T> && Decrementable<T>;
```

#### 12.5.3 미리 정의된 표준 콘셉트

- **코어 언어 콘셉트**: `same_as`, `derived_from`, `convertible_to`, `integral`, `floating_point`, `copy_constructible` 등
- **비교 콘셉트**: `equality_comparable`, `totally_ordered` 등
- **객체 콘셉트**: `movable`, `copyable` 등
- **클래블 콘셉트**: `invocable`, `predicate` 등

모든 스펙을 다 볼순 없고 책에선 `derived_from`를 포함한 몇가지 예시정도만 나옴

```c++
template <typename T>
concept IsDerivedFromFoo = derived_from<T, Foo>;
```

#### 12.5.4 auto 타입 제약조건 지정하기

앞서 말한 증가 연산자의 여부가 `Incrementable<T>` 라는 이름의 콘셉트로 지정되어있다고 하자

```c++
Incrementable auto value1{ 1 }; // 컴파일 성공

// 다음 코드는 컴파일 에러 발생
// Incrementable 타입 제약 조건을 만족하지 않음
Incrementable auto value{ "abc"s };
```

#### 12.5.5 타입 제약조건과 함수 템플릿

함수 템플릿에서 타입 제약조건을 넣는 방법은 다양함. 아래 참고

```c++
template <convertible_to<bool> T>
void handle(const T& t);

template <Incrementable T>
void process(const T& t);
```

`process`는 `int`는 가능하겠지만 `string`은 안된다

아래와 같이 `require` 구문을 사용하는 방법도 있다.

```c++
template <typename T> requires 상수_표현식
void process(const T& t);

template <typename T> requires Incrementable<T> // 사용자 정의
void process(const T& t);

template <typename T> requires convertible_to<T, bool> // 표준
void process(const T& t);
```

아래와 같이 다양하게 사용이 가능함.

콘셉트를 해당 순간에 지정하거나, 논리연산자를 쓰거나, 표준콘셉을 사용하거나 등등

```c++
template <typename T> requires requires(T x) { x++; ++x; }
void process(const T& t);

template <typename T> requires (sizeof(T) == 4)
void process(const T& t);

template <typename T> requires Incrementable<T> && Decrementable<T>
void process(const T& t);

template <typename T> requires is_arithmetic_v<T>
void process(const T& t);

template <typename T>
void process(const T& t) requires Incrementable<T>;

void process(const Incrementable auto& t);
```

##### 12.5.5.1 제약 조건 포함 관계

컴파일러는 주어진 제약조건 중 가장 구체적인걸 사용한다고 한다.

```c++
template <typename T> requires integral<T>
void process(const T& t) {
    cout << "integral<T>" << endl;
}

template <typename T> requires (integral<T> && sizeof(T) == 4)
void process(const T& t) {
    cout << "integral<T> && sizeof(T) == 4" << endl;
}

// Example calls
process(int(1));   // If int is 32-bit
process(short(2)); // If short is 16-bit
```

위 코드에 대한 출력은 아래와 같다.

```c++
integral<T> && sizeof(T) == 4
integral<T>
```

#### 12.5.6 타입 제약 조건과 클래스 템플릿

앞선 예제는 모두 함수템플릿

```c++
// GameBoard 클래스 정의 (타입 제약 사용)
template <std::derived_from<GamePiece> T>
class GameBoard : public Grid<T> {
public:
    explicit GameBoard(size_t width = Grid<T>::DefaultWidth,
                       size_t height = Grid<T>::DefaultHeight)
        : Grid<T>(width, height) {}

    void move(size_t xSrc, size_t ySrc, size_t xDest, size_t yDest);
};

// move 메서드 구현
template <std::derived_from<GamePiece> T>
void GameBoard<T>::move(size_t xSrc, size_t ySrc, size_t xDest, size_t yDest) {
    // ...
}

// requires 구문을 사용하는 경우
template <typename T>
requires std::derived_from<T, GamePiece>
class GameBoard : public Grid<T> {
    // ...
};
```

#### 12.5.7 타입 제약 조건과 클래스 메소드

```c++
template <std::derived_from<GamePiece> T>
class GameBoard : public Grid<T>
{
public:
    explicit GameBoard(size_t width = Grid<T>::DefaultWidth,
                       size_t height = Grid<T>::DefaultHeight);
    void move(size_t xSrc, size_t ySrc, size_t xDest, size_t yDest)
        requires std::movable<T>; // movable 제약조건 추가
};

template <std::derived_from<GamePiece> T>
void GameBoard<T>::move(size_t xSrc, size_t ySrc, size_t xDest, size_t yDest)
    requires std::movable<T> // movable 제약조건 추가
{
    // ...
}
```

메소드에 `movable`제약조건을 추가해서 쓰는걸 볼 수 있다.

선택적 인스턴스화 덕분에 `move`를 사용만 안하면 인스턴스화 자체가 막히진 않음

#### 12.5.8 타입 제약 조건과 템플릿 특수화

```c++
// 원래 쓰던거
// 부동소수점 연산은 `==`에 적절하지 않다. 이론상 추론값이라 사용이 불가능한것에 가깝다.
template <typename T>
size_t Find(const T& value, const T* arr, size_t size)
{
    for (size_t i { 0 }; i < size; i++) {
        if (arr[i] == value) {
            return i; // 원소를 찾으면 인덱스를 리턴한다.
        }
    }
    return NOT_FOUND; // 찾지 못하면 NOT_FOUND를 리턴한다.
}

// floating pint 제약조건 추가
// 이러면 입실론비교를 통해 ==에 대한 구현을 따로가져갈 수 있다.
template <std::floating_point T>
size_t Find(const T& value, const T* arr, size_t size)
{
    for (size_t i { 0 }; i < size; i++) {
        if (AreEqual(arr[i], value)) {
            return i; // 원소를 찾으면 인덱스를 리턴한다.
        }
    }
    return NOT_FOUND; // 찾지 못하면 NOT_FOUND를 리턴한다.
}

// 메소드 추가
// 입실론 검사
template <std::floating_point T>
bool AreEqual(T x, T y, int precision = 2)
{
    // 임실론을 주어진 precision 크기만큼 확대한다. 원하는 정밀도만큼 비교한다.
    return fabs(x - y) < numeric_limits<T>::epsilon() * fabs(x + y) * precision
        || fabs(x - y) < numeric_limits<T>::min(); // 결과는 초소값(subnormal)다.
}
```
